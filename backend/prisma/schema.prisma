generator client {
  provider = "prisma-client-js"
}

/// Always after the prisma-client-js generator
generator json {
  provider = "prisma-json-types-generator"
  // namespace = "PrismaJson"
  // clientOutput = "<finds it automatically>"
  // (./ -> relative to schema, or an importable path to require() it)
}

datasource db {
  provider = "postgresql"
  url      = env("DATABASE_URL")
}

model Channel {
  id              String   @id
  title           String
  description     String
  /// [Thumbnails]
  thumbnails      Json
  publishedAt     DateTime
  defaultLanguage String?

  playlistId String

  viewCount       BigInt
  subscriberCount Int
  videoCount      Int

  /// [Keywords]
  keywords Json
  country  String

  group String

  @@index([group])
}

model YoutubeStream {
  videoId         String   @id
  publishedAt     DateTime @db.Timestamptz(3)
  channelId       String
  title           String
  description     String?
  /// [Thumbnails]
  thumbnails      Json
  tags            String[]
  categoryId      Int      @db.SmallInt
  defaultLanguage String?

  duration           String?
  scheduledStartTime DateTime  @db.Timestamptz(3)
  actualStartTime    DateTime? @db.Timestamptz(3)
  actualEndTime      DateTime? @db.Timestamptz(3)

  maxViewerCount           Int  @default(0)
  averageConcurrentViewers Int  @default(0)
  chatMessages             Int  @default(0)
  views                    Int?
  likeCount                Int  @default(0)

  status    String
  group     String
  updatedAt DateTime @default(now()) @db.Timestamptz(3)

  superChats YoutubeStreamSuperChat[]

  @@index([channelId])
  @@index([status, group])
}

model YoutubeStreamViewerCount {
  id        Int      @id @default(autoincrement())
  videoId   String
  count     Int      @default(0)
  createdAt DateTime @default(now()) @db.Timestamptz(3)

  @@index([videoId, createdAt])
}

model YoutubeStreamChatCount {
  id                BigInt   @id @default(autoincrement())
  videoId           String
  all               Int      @default(0)
  member            Int      @default(0)
  nextContinuation  String?
  latestPublishedAt DateTime @db.Timestamptz(3)
  createdAt         DateTime @default(now()) @db.Timestamptz(3)

  @@index([videoId, createdAt])
}

model YoutubeStreamChatBundleQueue {
  id        Int      @id @default(autoincrement())
  status    String
  videoId   String   @unique
  createdAt DateTime @default(now()) @db.Timestamptz(3)
}

model YoutubeStreamSupersBundleQueue {
  id        Int      @id @default(autoincrement())
  status    String
  videoId   String   @unique
  createdAt DateTime @default(now()) @db.Timestamptz(3)
}

model YoutubeStreamSuperChat {
  id                  String @id
  amountMicros        BigInt
  currency            String
  amountDisplayString String
  userComment         String

  // author
  authorChannelId       String
  authorDisplayName     String
  authorProfileImageUrl String
  authorIsChatSponsor   Boolean

  videoId   String
  group     String
  createdAt DateTime @default(now()) @db.Timestamptz(3)

  stream YoutubeStream @relation(fields: [videoId], references: [videoId], onDelete: Cascade)

  @@index([videoId, createdAt])
  @@index([videoId, amountMicros])
  @@index([videoId, currency])
  @@index([group, createdAt])
  @@index([group, amountMicros, createdAt])
}

model YoutubeStreamSuperSticker {
  id                  String @id
  amountMicros        BigInt
  currency            String
  amountDisplayString String

  // author
  authorChannelId       String
  authorDisplayName     String
  authorProfileImageUrl String
  authorIsChatSponsor   Boolean

  videoId   String
  group     String
  createdAt DateTime @default(now()) @db.Timestamptz(3)

  @@index([videoId, createdAt])
  @@index([videoId, amountMicros])
  @@index([videoId, currency])
  @@index([group, createdAt])
  @@index([group, amountMicros, createdAt])
}

model YoutubeStreamSupersBundle {
  videoId         String   @id
  channelId       String
  /// JPY
  amountMicros    BigInt
  count           Int
  actualStartTime DateTime @db.Timestamptz(3)
  actualEndTime   DateTime @db.Timestamptz(3)
  group           String
  createdAt       DateTime @default(now()) @db.Timestamptz(3)

  @@index([actualStartTime, amountMicros])
  @@index([actualEndTime, amountMicros])
  @@index([channelId, actualStartTime, amountMicros])
  @@index([channelId, actualEndTime, amountMicros])
  @@index([group, actualStartTime, amountMicros])
  @@index([group, actualEndTime, amountMicros])
}

model ExchangeRate {
  currency  String   @id
  rate      Float
  updatedAt DateTime @updatedAt @db.Timestamptz(3)
}
